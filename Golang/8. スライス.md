## スライス

Goのスライスは配列を元にした可変調のデータ構造で、より柔軟な操作が可能。

スライスは配列と違ってサイズを自由に変更でき、Goではスライスが主に使用される。

## index

- [スライスの宣言と初期化](スライスの宣言と初期化)



## スライスの宣言と初期化

スライスは配列に基づいているため、型を指定して宣言するが、長さは指定しない。

```Go
var slice []int
```

この時点では、スライスはまだ要素を持っていない。(nilスライス)
そのため、スライスの長さは０になる。

スライスの初期化方法は複数存在するが、配列同様に宣言と同時に初期化することができる。

```Go
slice := []int{1,2,3}
```

## make関数を利用したスライスの作成

make関数を利用してスライスを作成することもできる。

```Go
slice := make([]int, 5)  // 長さ5のスライスを作成、要素はデフォルト値0
```

この場合、要素が０で初期化された長さ５のスライスが作成される。
make関数ではキャパシティ(容量)も指定可能。キャパシティはメモリを効率よく使用するための最大容量になる。

```Go
slice := make([]int, 5, 10)  // 長さ5、容量10のスライスを作成
```

## スライスの長さとキャパシティ

```Go
fmt.Println(len(slice))  // 長さ
fmt.Println(cap(slice))  // キャパシティ
```

## スライスの操作

```Go
slice[0] = 10 // 1番目の要素を変更
fmt.Println(slice[0]) // 変更された要素を表示
```

## スライスの部分取得(スライシング)

スライスから一部を取り出すことができる。`[開始：終了]`の形式で指定し、開始インデックスは含まれるが、終了インデックスは含まれない。

```Go
slice := []int{1,2,3,4,5}
subSlice := slice[1:4] // 2番目から4番目までの要素を取得
fmt.Println(subSlice) // [2 3 4]
```

