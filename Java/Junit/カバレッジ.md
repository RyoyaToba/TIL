## カバレッジ率（網羅率）について

> カバレッジは、所定の網羅条件がテストによってどれだけ実行されたかを割合で表したもの。網羅条件が命令であれば、命令網羅と呼ばれ（ステートメントガバレッジC0）
> すべての時効可能な命令のうち、テストで実行された命令の割合を意味している。そのほかに条件判定（if分岐）のうち、テストで実行された判定条件を意味する判定条件
> 網羅（ブランチカバレッジC1）などがある。

引用元  https://www.techmatrix.co.jp/t/quality/coverage.html

### カバレッジの種類

**行カバレッジ**

すべてのコード行のうち、テストで実行された行の割合

**ステートメントカバレッジ（C0：命令網羅率）**

すべての実行可能命令(ステートメント)のうち、テストで実行された命令の割合です。

**ブロックカバレッジ**

すべてのブロックのうち、テストで実行されたブロックの割合です。ブロックは、if文などによる分岐を含まない一連のステートメントです。

**パスカカバレッジ**

すべてのパス（可能な実行経路）のうち、テストで実行されたパスの割合です。

**判断文カバレッジ（ブランチカバレッジ、C1：分岐網羅率）**

すべての判定条件のうち、テストで実行された判定条件の割合です。

**単純条件カバレッジ（C2：条件網羅率）**

すべての条件のうち、テストで実行された条件の割合です。
判断文カバレッジ との違いは、1つの判断文には(ANDやORで接続された)複数の条件が含まれる場合がありますが、 
判断文カバレッジでは判断文全体が真と偽の両方の値を取ればよいのに対し、単純条件カバレッジでは個々の条件が真と偽の両方の値を取る必要がある点です。

**Modified Condition/Decision Coverage (MC/DC)カバレッジ**

MC/DCは、国際技術標準 DO-178B(RTCA)に準拠しています。
これは、ソフトウェア証明のための基準を指定したものであり、対象となるソフトウェアには、
航空業界で使用される重要機器およびシステムのためのリアルタイム組込みシステムも含まれます。
DO-178Bに従うと、完全な(100%の)MC/DCカバレッジ を得るには、次の3つの条件を満たす必要があります。 

a.各「判断文」が、少なくとも1回すべての可能な結果を得ている。
b.1つの「判断文」中の各条件が、少なくとも1回すべての可能な結果を得ている。
c.1つの「判断文」中の個々の条件が、単独で全体の「判断文」の結果を左右する。

**関数カバレッジ**

すべての関数のうち、テストで最低1回実行された関数の割合です。

**コールカバレッジ**

すべての関数呼び出しのうち、テストで呼び出された関数の割合です。


## コード例で紹介している部分があったので、引用させてもらいます

引用元：https://tech.naturalmindo.com/notwork_coverage/


```Java
int abs(int x){
  if (x < 0){
    x = -x;
  }
  return x;
}
```

**C0：命令網羅（ステートメント・カバレッジ）**

全ての命令を実行すればC0は１００％になる（いいかたを変えれば、通っていない処理がなくなればC0は１００％になる）
従って、上記例文では、if文の中に入ればOK。

**C1:分岐網羅（ブランチ・カバレッジ）**

すべての分岐における全ての方向を実行すればC1は１００％となる

従って、上記ではx=-1とx=0を用いたテストケース２つあれば良い。

**C2：条件網羅（コンディション・カバレッジ）**

条件式において、全ての可能な結果を少なくとも１回は通るように実行すれば良い。

注目点は条件式になるので、C2が１００％になっても、C0、C1が１００％になるとは限らない。

```Java
if (x > 0 || y > 0){...}
```

上記のような条件分岐の場合、x > 0の真偽、y > 0の真偽の両方を考慮する必要がある。
従って、以下の４通りのテストケースが必要となる。

1. x > 0, y > 0
2. x > 0, y <= 0
3. x <= 0, y > 0
4. x <= 0, y <= 0

ただし、上記の場合、x > 0の時点で最初の判定が真であれば、yの判定は不用になるので、実質1か2として合計３つのケースで良い。


## 確認

複雑なコードを用いて、カバレッジ１００％にするには、テストケースが何通りか考えてみる。

```Java
void function(...) {
    if ( 条件a1 || 条件a2 ) { // 判定条件A
        命令1
    } else {
        命令2
    }
    if ( 条件b ) { // 判定条件B
        命令3
    }
}
```

### C0：命令網羅

**Point：命令を全て実行しているか**

→ 命令１、２、３をすべて実行するようにテストケースを考える

命令文３つのケースが必要であるが、２ケースで通せる

答え：２通り（命令１を通って命令３を通るケース、　命令２を通るケース）



### C1:分岐網羅

**Point：分岐を全て網羅しているか（各分岐で真偽を網羅する）**

→ 分岐全てのtrue,falseを網羅するようにテストケースを考える

判定条件Aでのtrue or false, 判定条件Bでのtrue or falseなので、合計で４通りが考えられる

だたし、上記コードであれば２パターンで全て通せるので、C0と同じケースになる。

答え：２通り（①命令１を通って命令３を通るケース、　②命令２を通って命令３を通らないケース）

①判定条件Aはtrue, 判定条件Bはtrue
②判定条件Aはfalse,　判定条件Bはfalse


### C2:条件網羅

**Point：全ての条件の真偽を網羅するようにテストケースを考える**

→ 条件a1, 条件a2, 条件bそれぞれの真偽を網羅する。

６通りが考えられる。例えば、最低以下のテストケースを２つ作ればC2は網羅できる。

条件a1=false、条件a2=false、条件b=falseのケース

条件a1=true、条件a2=true、条件b=trueのケース

ちなみに、上記であれば、C0、C1も網羅できるが、以下の場合にはC2を網羅できても、C0とC1は命令２が通らないため網羅できない。

条件a1=false、条件a2=true、条件b=falseのケース

条件a1=true、条件a2=false、条件b=trueのケース


また、C2は、複合条件網羅（考えられる全てのパターンを通らないといけない）として混同されることがあります。

複合条件網羅の場合、全ての条件の組み合わせを考える必要があります。

つまり、以下の８ケースが考えられます。

条件a1=false、条件a2=false、条件b=falseのケース

条件a1=false、条件a2=false、条件b=trueのケース

条件a1=false、条件a2=true、条件b=falseのケース

条件a1=false、条件a2=true、条件b=trueのケース

条件a1=true、条件a2=false、条件b=falseのケース

条件a1=true、条件a2=false、条件b=trueのケース

条件a1=true、条件a2=true、条件b=falseのケース

条件a1=true、条件a2=true、条件b=trueのケース

ただし、最後の４ケースについては、条件a1がtrueの時点で、条件Bは判定されず、true/falseどちらでもよいことになるため、テストケースとしては実質的に６ケースあればよいことになります。

条件a1=false、条件a2=false、条件b=falseのケース

条件a1=false、条件a2=false、条件b=trueのケース

条件a1=false、条件a2=true、条件b=falseのケース

条件a1=false、条件a2=true、条件b=trueのケース

条件a1=true、条件a2=DC、条件b=falseのケース

条件a1=true、条件a2=DC、条件b=trueのケース

