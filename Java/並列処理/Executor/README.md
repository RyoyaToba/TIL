## Executorフレームワーク

マルチスレッドによる並行処理は、使い方を間違えるとパフォーマンスの低下につながる。

Threadを用いたマルチスレッド・プログラミングでは、Threadクラスのサブクラスを作り、runメソッドをオーバーライドしたり、Runnableインターフェイスの実装を定義してTreadクラスのコンストラクタ
に渡したりして、新しいスレッドで行う処理と、それを実行するスレッドでのインスタンスをセットで扱っていた。

しかし、この方法では、実行したい処理が100個あれば、100個のスレッドを生成する必要がある。途中のスレッドを生成しているときに、1番最初のスレッドの処理が終了している可能性があり、コンピュー
ターに付加をかけて、新しいスレッドを生成していることになる。

このときに生じる「スレッドの無駄遣い」という問題を解決するために、あらかじめスレッドを生成して保存しておき、使いまわしをする仕組みが、JavaSE5で導入された。これが**スレッドプール**
である。

スレッドプールは予め、複数個の空のスレッドを生成し、そのスレッドにタスクを与えて実行させる。このようにタスクが与えられるまで待機する空のスレッドと、タスクを実行するスレッドを分けることで
前述の「スレッドの無駄遣い」の問題を解決する。

スレッドプールを使ことで、効率的に並行処理を実現するのがExecutorフレームワークと呼ばれる一連のインターフェイスとクラス群である。このフレームワークは、java.util.concurrent.Executorを
スーパーインターフェイスとした、次のようなインターフェイスで構成されている。

具体的な使用方法としては、Executorのサブインターフェイスであるjava.util.concurrent.ExecutorService、もしくはjava.util.concurrent.ScheduledExecutorServiceを利用する。

これらのサブインターフェイスの実装を取得するのがjava.util.concurrent.Executorsクラスである。このクラスは。ExecutorServiceインターフェイスを実現したインスタンスへの参照を戻すファクトリメソッドを用途別にいくつか持っている。

