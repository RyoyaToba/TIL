## クラスとインターフェイス

**１：ネストしたクラス**

ネストしたクラスについて、名称とそれぞれの特徴を理解する

- [インナークラス](インナークラス.md)
  - クラスの中に定義したクラス。
  - エンクロージングクラスのメンバとして定義されるので、修飾子は自由につけられる。
- [staticインナークラス](staticインナークラス.md)
  - クラスの中にstaticで定義したクラス。
  - エンクロージングクラスのメンバとして定義されるので、修飾子は自由につけられる。
- [ローカルクラス](ローカルクラス.md)
  - メソッド内に定義したクラス。
- [匿名クラス](匿名クラス.md)
  - メソッド内に定義したクラス。

<br>

**２：ネストしたクラスのインスタンス化**

- ネストしたクラスをインスタンス化するには、エンクロージングクラスを先にインスタンス化しなければならない。
- staticインナークラスをインスタンス化するときは、エンクロージングクラスをインスタンス化しなくていい。通常のメソッド内に定義されたstaticメソッドをクラス名経由で利用できるのと同じ原理。

<br>

**３：フィールドやメソッドへのアクセス**

- staticインナークラスから、エンクロージングクラスに定義された非staticなフィールドやメソッドにはアクセスできない。これは通常のクラスにおける、staticメソッドから非staticなフィールドにアクセスできないのと同じ原理。

<br>

**４：非staticインナークラスに定義できるメンバ**

- staticで就職されていないインナークラスには、staticのメンバを定義することはできない。
- 逆にstaticインナークラスには、修飾、非修飾のどちらのメンバも定義できる。

<br>

**５：ローカルクラスが参照する変数のルール**

- ローカルクラスが参照するローカル変数は、ローカルクラスの定義よりも前に宣言されていなければならない。
- ローカルクラスが参照するローカル変数は、実質的にfinalでなければならない。

<br>

**６：匿名クラスを利用してメソッドを定義したときの格納変数型にvarを利用する**

- 匿名クラスを利用することで、独自のメソッドを追加することができるが、戻り型にvarを利用せずに、元の型に代入しメソッドを利用するとコンパイルエラーが発生する。

<br>

**７：匿名クラスとコンストラクタ**

- 匿名クラスにコンストラクタは定義できない。クラスの名前がないから。

<br>

**８：インターフェイスに定義できるメソッド**

- インターフェイスにはstaticメソッドが定義できる（できるようにjava8からなった）。このstaticメソッドは、継承したサブインターフェイス名や実現したクラス名を用いて利用することはできず、必ず`定義したインターフェイス名.メソッド名`である必要がある。
- クラスに定義したstaticメソッドをオーバーライドすることができないのと同様に、インターフェイスに定義したstaticメソッドもオーバーライドできない。オーバーライドアノテーションをつけるとコンパイルエラーになる。
- スーパーインターフェイスに定義されたdefaultメソッドを呼び出すときは、`スーパーインターフェイス名.super.メソッド名`と記述する。呼び出せるのは直接の継承元か、継承しているものの１つ上の階層に限る。
- インターフェイスとクラスに同じ名前のメソッドが定義されており、それを継承と実現しているクラスが、同名のメソッドを読んだ場合、クラスに定義されているメソッドが優先される。その際に、クラス側の修飾子がインターフェイス側よりも厳しくなっていないか確認すること。
- Java9から、処理をもつprivateメソッドを定義できるようになった。処理を記述しないprivateメソッドは定義できない（処理を書かないということは、実現される必要があるので、必然的にpublicになるため）

<br>

**９：Enum**

- Enumにはデフォルトで、`valuesメソッド`（Enumに定義されている列挙子を配列に入れて戻す）と`valueOfメソッド`（引数で指定した列挙子のインスタンスを戻す）が定義されている。
- Enumのコンスタラクタはprivateでしか定義できない。省略した場合は、暗黙的にprivatetと解釈される。

