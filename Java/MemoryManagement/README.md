## MemoryManagement

https://www.geeksforgeeks.org/java-memory-management/

の記事を自分なりに咀嚼して、Javaにおけるメモリリークに関して知識を深めていきます。

この記事では、ガベージコレクションとかもろもろの話をしていきます。

## なんでJavaのメモリマネジメントについて学ぶの？

Javaにはガベージコレクションがあって、プログラマーが意識せずとも不必要なメモリを解放してくれるので、なんで勉強するんだい？

結局、ガベージコレクションがカバーしてくれない部分もあるし、JVMがどんなことをしているのかを知っていた方が、デバックとかもしやすいよね！

## 序章

どんな言語でもメモリ管理ってめっちゃ重要で、JavaだとJVMいわゆるガベージコレクターが自動管理してくれる。

C言語とかはそういうのないから大変なんだよ〜。

ここでは

Javaのメモリ管理における重要なコンテンツについて勉強していくよ。

* JVMのメモリ構造について
* ガベージコレクタの働きについて

## Javaのメモリ構造について

JVMはプログラムの実行中に使用されるさまざまな実行値データ領域を定義して、作成するんだけど、一部はプログラムで使用されるスレッドが作成するんだ。

JVMが作成したメモリ領域は、JVMが消失するときに同時に破棄されるよ。スレッドのデータ領域はインスタンス化するときに作成されて、スレッドの消失とともに破棄されるよ。

![Memory](https://user-images.githubusercontent.com/105257856/204286431-1c33d8ab-a5e0-435c-9c0a-e5163d8c65f6.png)

https://www.geeksforgeeks.org/java-memory-management/

ではもう少し詳しくみていこう！

## ヒープ領域

* 共有ランタイムデータ領域で、実際のオブジェクトをメモリに格納するの。仮想マシンの起動時にインスタンス化されるよ
* このメモリは全てのクラスインスタンスと配列に割り当てられるよ。ヒープはシステムの構成に応じて、静的サイズだったり動的サイズだったりするよ。
* JVMがヒープのサイズをコントロールしてくれるの。`new`を使ってオブジェクトにヒープ領域が割り当てられて、その参照はスタック領域にあるよ。
* 実行中のJVMには１つのヒープ領域が存在するよ。

```Java
Scanner sc = new Scanner(System.in);
```

上記のコードでは、参照「sc」がスタック領域にプッシュされて、ヒープ領域にScannerクラスのインスタンスが割り当てられるよ。

ヒープ領域のガベージコレクションは必須だよ。

## メソッド領域

* ヒープ領域のロジカル的な部分で、仮想マシンの立ち上がりの時に作成されるよ
* クラス構造体、メソッドデータ、コンストラクタ、フィールドデータ、およびクラスで使用されるインターフェイスとか特別なクラスに割り当てられるよ。ヒープはシステムの構成に応じて、静的サイズだったり動的サイズだったりするよ。
* 固定にもできるし、拡張することもできるよ。連続している必要はないよ。

メソッド領域は論理的にはヒープの一部なんだけど、ヒープ領域でガベージコレクションが強制されてても、ガベージコレクションされる場合とされない場合があるよ〜。

## JVM Stack

* スレッドの生成と同時に作成されるよ。メソッドの値を返して、動的リンクを実行するときに必要なデータと部分的な結果を格納するために用いるよ。
* スタックは、固定サイズまたは動的サイズのいずれかで、スタックのサイズは、作成時に個別に選択できるよ。
* スタックのメモリは連続してなくてもいいよ。

## Native method Stacks

Cスタックとも呼ばれるネイティブメソッドスタックは、Java言語で記述されてないよ。
このメモリは、スレッドの作成時に各スレッドに割り当てられて、固定的または動的な性質を持つことができるよ。

## Program counter (PC) registers

特定のメソッドのタスクを実行する各JVMスレッドには、関連付けられたプログラムカウンターレジスタがあって、非ネイティブメソッドには、使用可能なJVM命令のアドレスを格納するPCがあるんだが、
ネイティブメソッドでは、プログラムカウンターの値は未定義だよ。PCレジスタは、特定のプラットフォームでリターンアドレスまたはネイティブポインタを格納できるよ。（いみわからん）

## ガベージコレクターのはたらき

* JVMはこのプロセスをトリガーし、JVMガベージコレクションプロセスに従って実行されるか、保留されるよ。メモリの割り当てや解放を自動で行うことで、プログラマの負担を軽減するよ。
* ガベージコレクションプロセスにより、残りのプロセスまたはスレッドが一時停止されるため、本質的にコストがかかるよ。
* この問題はクライアントには受け入れられませんが、いくつかのガベージコレクターベースのアルゴリズムを適用することで解消できるよ。
* アルゴリズムを適用するこのプロセスは、ガベージコレクターのチューニングと呼ばれることが多く、プログラムのパフォーマンスを向上させるために重要だよ。
* もう1つの解決策は、メモリが割り当てられたオブジェクトに ageフィールドを追加する世代別ガベージコレクターだよ。より多くのオブジェクトが作成されると、ガベージのリストが大きくなり、ガベージコレクションの時間が長くなるよ。オブジェクトが生き残ったクロックサイクル数に基づいて、オブジェクトはグループ化され、それに応じて「age」が割り当てられます。このようにして、ガベージコレクションの作業が分散されるよ（・・・？）。
* 現在のシナリオでは、すべてのガベージコレクターは世代別であるため、最適です。

System.gc() および Runtime.gc() は、明示的に JVMにガベージコレクションを要求するメソッドですが、ガベージコレクションの最終決定は JVMのみであるため、ガベージコレクションを保証するものではありません。

プログラムとそのデータがどのように保存または編成されているかを知ることは、プログラマーがリソースとその消費に関して最適化されたコードを作成しようとするときに役立つため、不可欠です。また、メモリ リークや不整合を見つけたり、メモリ関連のエラーをデバッグしたりするのにも役立ちます。ただし、メモリ管理の概念は非常に広大であるため、知識を向上させるためにできるだけ多くのことを研究するために最善を尽くす必要があります。

## Memory Management in Java

別の記事で勉強していくよ

https://www.javatpoint.com/memory-management-in-java

Javaにはガベージコレクションがメモリの管理をしてくれるから、メモリ管理のロジックを書く必要がないんだよね。おもに大事なのはこの２つね。

* JVM Memory Structure
* Working of the Garbage Collector

## JVM Memory Structure

JVMは、ヒープ内にさまざまなランタイムデータ領域を作成すんねん。
これらの領域は、プログラム実行中に使用されて。
メモリ領域はJVMの終了時に破棄されるんやが、データ領域はスレッドの終了時に破棄されるんや。


## ガベージコレクションについてもっと勉強してみよう

https://gihyo.jp/dev/serial/01/jvm-arc/0005


