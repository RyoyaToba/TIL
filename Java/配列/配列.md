## 配列

## 呼び出した時の挙動

変数には配列の参照が入っているため、Sysoutなどでアクセスを試みるとハッシュ値が返る

```Java
public static void main(String[] args){
  int[] array = new int[0];
  System.out.println(array);　// [I@372fa8dなど
}
```

## 宣言方法

以下どの形の宣言でもエラーにならない

```Java
int[] a;
int b[];
int[][] c;
int d[][];
int[] e[];
int[][] f[];
```

配列の宣言は、インスタンス化を行う時に、配列の要素数を宣言する。宣言しないとコンパイルエラーになる。

```Java
int[] a = new int[]; // error
```

次のように変数を宣言する段階で数を指定することはできない。あくまでも、インスタンス化の時に数を宣言する。

```Java
int[3] a; // error
```

以下のようにインスタンス化するときに数の宣言をする。

```Java
int[] a = new int[3];
```

二次元配列をインスタンス化する際、１次元目の数を省いて２次元目の数のみを指定することはできない。

```Java
int[][] a = new int[][3]; // error
```

多次元配列が階層になっているのをイメージすれば大丈夫だと思う。よってこれは可能。

```Java
int[][] a = new int[3][]; // OK
```

## インスタンスの生成と初期化

インスタンス化と初期化を同時に行う方法は次の２通りが存在する。


➀　初期化子を直接記述して初期化＋インスタンス化

```Java
int[] a = {2,3};
```

➁　newを用いて初期化＋インスタンス化

```Java
int[] a = new int[]{2,3};
```

ただし、newを用いて初期化＋インスタンス化を行う場合、`[ ]`内には数を書くことができない。`{ }`内の記述から自動で計算される。そのため、次の記述はコンパイルエラーとなる。
初期化子を用いない場合（宣言のみ）なら、`[ ]`への記述は必要なので注意。

```Java
int[] a = new int[2]{2,3} // error
```
